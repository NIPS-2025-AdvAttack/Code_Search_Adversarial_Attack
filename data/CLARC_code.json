{
    "c_group_1_id_325": "inline auto tm_wday_full_name(int wday) -> const char* {\n  static constexpr const char* full_name_list[] = {\n      \"Sunday\",   \"Monday\", \"Tuesday\", \"Wednesday\",\n      \"Thursday\", \"Friday\", \"Saturday\"};\n  return wday >= 0 && wday <= 6 ? full_name_list[wday] : \"?\";\n}",
    "c_group_1_id_327": "inline std::string &to_lower_(std::string &str) {\n    std::transform(str.begin(), str.end(), str.begin(), [](char ch) {\n        return static_cast<char>((ch >= 'A' && ch <= 'Z') ? ch + ('a' - 'A') : ch);\n    });\n    return str;\n}",
    "c_group_1_id_328": "CGLM_INLINE\nfloat\nglm_bezier(float s, float p0, float c0, float c1, float p1) {\n  float x, xx, ss, xs3, a;\n\n  x   = 1.0f - s;\n  xx  = x * x;\n  ss  = s * s;\n  xs3 = (s - ss) * 3.0f;\n  a   = p0 * xx + c0 * xs3;\n\n  return a + s * (c1 * xs3 + p1 * ss - a);\n}",
    "c_group_1_id_329": "static double corrcoef(int N,double *x,double *y) {\n\tdouble cc,xm,ym,tx,ty,num,den1,den2;\n\tint i;\n\txm = ym = 0.0;\n\tfor(i = 0; i < N;++i) {\n\t\txm += x[i];\n\t\tym += y[i];\n\t}\n\n\txm = xm/N;\n\tym = ym / N;\n\tnum = den1 = den2 = 0.0;\n\n\tfor(i = 0; i < N;++i) {\n\t\ttx = x[i] - xm;\n\t\tty = y[i] - ym;\n\t\tnum += (tx*ty);\n\t\tden1 += (tx*tx);\n\t\tden2 += (ty*ty);\n\t}\n\n\tcc = num / sqrt(den1*den2);\n\n\treturn cc;\n}",
    "c_group_1_id_330": "int testSWTlength(int N, int J) {\n\tint ret,div,i;\n\tret = 1;\n\n\tdiv = 1;\n\tfor (i = 0; i < J; ++i) {\n\t\tdiv *= 2;\n\t}\n\n\tif (N % div) {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n\n}",
    "c_group_1_id_331": "inline auto do_count_digits(uint64_t n) -> int {\n  \n  \n  \n  \n  static constexpr uint8_t bsr2log10[] = {\n      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,\n      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,\n      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,\n      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};\n  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];\n  static constexpr const uint64_t zero_or_powers_of_10[] = {\n      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),\n      10000000000000000000ULL};\n  return t - (n < zero_or_powers_of_10[t]);\n}",
    "c_group_1_id_332": "FMT_CONSTEXPR inline auto multiply(uint64_t lhs, uint64_t rhs) -> uint64_t {\n#if FMT_USE_INT128\n  auto product = static_cast<__uint128_t>(lhs) * rhs;\n  auto f = static_cast<uint64_t>(product >> 64);\n  return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;\n#else\n  \n  uint64_t mask = (1ULL << 32) - 1;\n  uint64_t a = lhs >> 32, b = lhs & mask;\n  uint64_t c = rhs >> 32, d = rhs & mask;\n  uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;\n  \n  uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);\n  return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);\n#endif\n}",
    "c_group_1_id_333": "int dirExists(const char *path) {\n  struct stat info;\n\n  if (stat(path, &info) != 0)\n    return 0;\n  else if (info.st_mode & S_IFDIR)\n    return 1;\n  else\n    return 0;\n}",
    "c_group_1_id_334": "double REL_Error(double *data, double *rec, int N) {\n    int i;\n    double sum1 = 0;\n    double sum2 = 0;\n    for (i = 0; i < N; ++i) {\n        sum1 += (data[i] - rec[i])*(data[i] - rec[i]);\n        sum2 += data[i] * data[i];\n    }\n    return sqrt(sum1)/sqrt(sum2);\n}",
    "c_group_1_id_335": "void\ninterleave_data (const float *in, float *out, int frames, int channels)\n{\tint fr, ch ;\n\n\tfor (fr = 0 ; fr < frames ; fr++)\n\t\tfor (ch = 0 ; ch < channels ; ch++)\n\t\t\tout [ch + channels * fr] = in [fr + frames * ch] ;\n\n\treturn ;\n}",
    "c_group_1_id_336": "double sum4(double *array, int N) {\n    double sum;\n    int i;\n\n    sum = 0.0;\n    for (i = 0; i < N; i += 1) {\n        sum += array[i] * array[i];\n    }\n    return sum;\n}",
    "c_group_1_id_337": "char const* getEnv( char const* varName ) {\n#    if defined( _MSC_VER )\n#        pragma warning( push )\n#        pragma warning( disable : 4996 ) \n#    endif\n\n            return std::getenv( varName );\n\n#    if defined( _MSC_VER )\n#        pragma warning( pop )\n#    endif\n        }",
    "c_group_1_id_338": "void dispWT2Coeffs(double *A, int row, int col) {\n\tint i, j;\n\tprintf(\"\\n MATRIX Order : %d X %d \\n \\n\", row, col);\n\n\tfor (i = 0; i < row; i++) {\n\t\tprintf(\"R%d: \", i);\n\t\tfor (j = 0; j < col; j++) {\n\t\t\tprintf(\"%g \", A[i*col + j]);\n\t\t}\n\t\tprintf(\":R%d \\n\", i);\n\t}\n}",
    "c_group_1_id_339": "static inline uint32_t ctz64(uint64_t n) {\n#if defined(__GNUC__) && UINT_MAX >= UINT32_MAX && ULLONG_MAX >= UINT64_MAX\n  return static_cast<uint32_t>(__builtin_ctzll(n));\n#elif defined(_WIN64) && defined(_MSC_VER) && _MSC_VER >= 1400 &&              \\\n    ULONG_MAX >= UINT64_MAX\n  uint32_t i;\n  _BitScanForward64((unsigned long *)&i, n);\n  return i;\n#else\n  uint32_t i = 1;\n  if ((n & static_cast<uint64_t>(4294967295)) == 0) {\n    n >>= 32;\n    i += 32;\n  }\n  if ((n & static_cast<uint64_t>(0x0000FFFFUL)) == 0) {\n    n >>= 16;\n    i += 16;\n  }\n\n  if ((n & static_cast<uint64_t>(0x000000FFUL)) == 0) {\n    n >>= 8;\n    i += 8;\n  }\n\n  if ((n & static_cast<uint64_t>(0x0000000FUL)) == 0) {\n    n >>= 4;\n    i += 4;\n  }\n\n  if ((n & static_cast<uint64_t>(0x00000003UL)) == 0) {\n    n >>= 2;\n    i += 2;\n  }\n  i -= (n & 0x1);\n  return i;\n#endif\n}",
    "c_group_1_id_340": "void dwt_sym_stride(double *inp, int N, double *lpd, double*hpd, int lpd_len, double *cA, int len_cA, double *cD, int istride, int ostride) {\n\tint i, l, t, len_avg;\n\tint is, os;\n\tlen_avg = lpd_len;\n\n\tfor (i = 0; i < len_cA; ++i) {\n\t\tt = 2 * i + 1;\n\t\tos = i *ostride;\n\t\tcA[os] = 0.0;\n\t\tcD[os] = 0.0;\n\t\tfor (l = 0; l < len_avg; ++l) {\n\t\t\tif ((t - l) >= 0 && (t - l) < N) {\n\t\t\t\tis = (t - l) * istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - l) < 0) {\n\t\t\t\tis = (-t + l - 1) * istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\t\t\telse if ((t - l) >= N) {\n\t\t\t\tis = (2 * N - t + l - 1) * istride;\n\t\t\t\tcA[os] += lpd[l] * inp[is];\n\t\t\t\tcD[os] += hpd[l] * inp[is];\n\t\t\t}\n\n\t\t}\n\t}\n\n\n}",
    "c_group_1_id_341": "static off_t\nfile_size(int fd)\n{\n\toff_t size;\n\tsize = lseek(fd, 0, SEEK_END);\n\tif (size == -1) {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: unable to lseek() input file: %s.\\n\",\n\t\t\tstrerror(errno));\n\t\texit(1);\n\t}\n\tif (lseek(fd, 0, SEEK_SET) == -1) {\n\t\tfprintf(stderr,\n\t\t\t\"ERROR: unable to lseek() input file: %s.\\n\",\n\t\t\tstrerror(errno));\n\t\texit(1);\n\t}\n\treturn size;\n}",
    "c_group_1_id_342": "void\ngen_windowed_sines (int freq_count, const double *freqs, double max, float *output, int output_len)\n{\tint \tk, freq ;\n\tdouble\tamplitude, phase ;\n\n\tamplitude = max / freq_count ;\n\n\tfor (k = 0 ; k < output_len ; k++)\n\t\toutput [k] = 0.0 ;\n\n\tfor (freq = 0 ; freq < freq_count ; freq++)\n\t{\tphase = 0.9 * M_PI / freq_count ;\n\n\t\tif (freqs [freq] <= 0.0 || freqs [freq] >= 0.5)\n\t\t{\tprintf (\"\\n%s : Error : freq [%d] == %g is out of range. Should be < 0.5.\\n\", __FILE__, freq, freqs [freq]) ;\n\t\t\texit (1) ;\n\t\t\t} ;\n\n\t\tfor (k = 0 ; k < output_len ; k++)\n\t\t\toutput [k] = (float) (output [k] + (amplitude * sin (freqs [freq] * (2 * k) * M_PI + phase))) ;\n\t\t} ;\n\n\t\n\tfor (k = 0 ; k < output_len ; k++)\n\t\toutput [k] = (float) (output [k] * (0.5 - 0.5 * cos ((2 * k) * M_PI / (output_len - 1)))) ;\n\n\t\n\n\treturn ;\n}",
    "c_group_1_id_347": "std::ostream &operator<<(std::ostream &dest, __uint128_t value) {\n  std::ostream::sentry s(dest);\n  if (s) {\n    __uint128_t tmp = value;\n    char buffer[128];\n    char *d = std::end(buffer);\n    do {\n      --d;\n      *d = \"0123456789\"[tmp % 10];\n      tmp /= 10;\n    } while (tmp != 0);\n    int len = int(std::end(buffer) - d);\n    if (dest.rdbuf()->sputn(d, len) != len) {\n      dest.setstate(std::ios_base::badbit);\n    }\n  }\n  return dest;\n}",
    "c_group_1_id_352": "std::pair<uint16_t, uint16_t> EncodeUTF16SurrogatePair(int codePoint) {\n  const uint32_t leadOffset = 0xD800 - (0x10000 >> 10);\n\n  return {\n    leadOffset | (codePoint >> 10),\n    0xDC00 | (codePoint & 0x3FF),\n  };\n}",
    "c_group_1_id_355": "const char *ft_strerror(int error_code)\n{\n    switch (error_code) {\n        case FT_MEMORY_ERROR:\n            return \"Out of memory\";\n        case FT_GEN_ERROR:\n            return \"General error\";\n        case FT_EINVAL:\n            return \"Invalid argument\";\n        case FT_INTERN_ERROR:\n            return \"Internal libfort error\";\n        default:\n            if (error_code < 0)\n                return \"Unknown error code\";\n            else\n                return \"Success\";\n    }\n}",
    "c_group_1_id_356": "int utf8cmp(const void *src1, const void *src2)\n{\n    const unsigned char *s1 = (const unsigned char *)src1;\n    const unsigned char *s2 = (const unsigned char *)src2;\n\n    while (('\\0' != *s1) || ('\\0' != *s2)) {\n        if (*s1 < *s2) {\n            return -1;\n        } else if (*s1 > *s2) {\n            return 1;\n        }\n\n        s1++;\n        s2++;\n    }\n\n    \n    return 0;\n}",
    "c_group_1_id_357": "size_t utf8cspn(const void *src, const void *reject)\n{\n    const char *s = (const char *)src;\n    size_t chars = 0;\n\n    while ('\\0' != *s) {\n        const char *r = (const char *)reject;\n        size_t offset = 0;\n\n        while ('\\0' != *r) {\n            \n            \n            \n            if ((0x80 != (0xc0 & *r)) && (0 < offset)) {\n                return chars;\n            } else {\n                if (*r == s[offset]) {\n                    \n                    \n                    offset++;\n                    r++;\n                } else {\n                    \n                    \n\n                    do {\n                        r++;\n                    } while (0x80 == (0xc0 & *r));\n\n                    \n                    offset = 0;\n                }\n            }\n        }\n\n        \n        \n        \n        do {\n            s++;\n        } while ((0x80 == (0xc0 & *s)));\n        chars++;\n    }\n\n    return chars;\n}",
    "c_group_1_id_358": "int utf8ncmp(const void *src1, const void *src2, size_t n)\n{\n    const unsigned char *s1 = (const unsigned char *)src1;\n    const unsigned char *s2 = (const unsigned char *)src2;\n\n    while ((0 != n--) && (('\\0' != *s1) || ('\\0' != *s2))) {\n        if (*s1 < *s2) {\n            return -1;\n        } else if (*s1 > *s2) {\n            return 1;\n        }\n\n        s1++;\n        s2++;\n    }\n\n    \n    return 0;\n}",
    "c_group_1_id_359": "size_t utf8size(const void *str)\n{\n    const char *s = (const char *)str;\n    size_t size = 0;\n    while ('\\0' != s[size]) {\n        size++;\n    }\n\n    \n    size++;\n    return size;\n}",
    "c_group_1_id_360": "static\nint snprint_n_strings_impl(char *buf, size_t length, size_t n, const char *str)\n{\n    size_t str_len = strlen(str);\n    if (length <= n * str_len)\n        return -1;\n\n    if (n == 0)\n        return 0;\n\n    \n    if (n * str_len > INT_MAX)\n        return -1;\n\n    if (str_len == 0)\n        return 0;\n\n    int status = snprintf(buf, length, \"%0*d\", (int)(n * str_len), 0);\n    if (status < 0)\n        return status;\n\n    size_t i = 0;\n    for (i = 0; i < n; ++i) {\n        const char *str_p = str;\n        while (*str_p)\n            *(buf++) = *(str_p++);\n    }\n    return (int)(n * str_len);\n}",
    "c_group_1_id_361": "static\nint wsnprint_n_string(wchar_t *buf, size_t length, size_t n, const char *str)\n{\n    size_t str_len = strlen(str);\n\n    \n    if (str_len > 1) {\n        const unsigned char *p = (const unsigned char *)str;\n        while (*p) {\n            if (*p <= 127)\n                p++;\n            else {\n                wchar_t wcs[WCS_SIZE];\n                const char *ptr = str;\n                size_t wcs_len;\n                mbstate_t mbst;\n                memset(&mbst, 0, sizeof(mbst));\n                wcs_len = mbsrtowcs(wcs, (const char **)&ptr, WCS_SIZE, &mbst);\n                \n                if ((wcs_len == (size_t) - 1) || wcs_len > 1) {\n                    return -1;\n                } else {\n                    wcs[wcs_len] = L'\\0';\n                    size_t k = n;\n                    while (k) {\n                        *buf = *wcs;\n                        ++buf;\n                        --k;\n                    }\n                    buf[n] = L'\\0';\n                    return (int)n;\n                }\n            }\n        }\n    }\n\n    if (length <= n * str_len)\n        return -1;\n\n    if (n == 0)\n        return 0;\n\n    \n    if (n * str_len > INT_MAX)\n        return -1;\n\n    if (str_len == 0)\n        return 0;\n\n    int status = swprintf(buf, length, L\"%0*d\", (int)(n * str_len), 0);\n    if (status < 0)\n        return status;\n\n    size_t i = 0;\n    for (i = 0; i < n; ++i) {\n        const char *str_p = str;\n        while (*str_p)\n            *(buf++) = (wchar_t) * (str_p++);\n    }\n    return (int)(n * str_len);\n}",
    "c_group_1_id_363": "int u8strwid(const void *beg, const void *end, size_t *width)\n{\n    const char *custom_str = \"custom_string\";\n    const size_t raw_len = (const char *)end - (const char *)beg;\n    if (memcmp(beg, custom_str, MIN(strlen(custom_str), raw_len)) == 0) {\n        *width = 25;\n        return 0;\n    }\n    return 1;\n}",
    "c_group_1_id_364": "int u8strwid(const void *beg, const void *end, size_t *width)\n{\n    const char *emojis[] = {\"\ud83d\ude03\", \"\ud83d\ude0d\"};\n    const size_t sz = sizeof(emojis) / sizeof(emojis[0]);\n    const size_t raw_len = (const char *)end - (const char *)beg;\n\n    for (size_t i = 0; i < sz; ++i) {\n        if (memcmp(beg, emojis[i], std::min(strlen(emojis[i]), raw_len)) == 0) {\n            *width = 2; \n            return 0;\n        }\n    }\n    return 1;\n}",
    "c_group_1_id_365": "inline void dump_mem_usage()\n{\n    FILE* f = fopen(\"/proc/self/statm\", \"rt\");\n    if (!f) return;\n    char   str[300];\n    size_t n = fread(str, 1, 200, f);\n    str[n]   = 0;\n    printf(\"MEM: %s\\n\", str);\n    fclose(f);\n}",
    "c_group_1_id_379": "inline auto digits2(size_t value) -> const char* {\n  \n  \n  alignas(2) static const char data[] =\n      \"0001020304050607080910111213141516171819\"\n      \"2021222324252627282930313233343536373839\"\n      \"4041424344454647484950515253545556575859\"\n      \"6061626364656667686970717273747576777879\"\n      \"8081828384858687888990919293949596979899\";\n  return &data[value * 2];\n}",
    "c_group_1_id_382": "inline void SleepMilliseconds(int n) {\n  const timespec time = {\n    0,                  \n    n * 1000L * 1000L,  \n  };\n  nanosleep(&time, nullptr);\n}",
    "c_group_1_id_383": "inline std::string CanonicalizeForStdLibVersioning(std::string s) {\n  static const char prefix[] = \"std::__\";\n  if (s.compare(0, strlen(prefix), prefix) == 0) {\n    std::string::size_type end = s.find(\"::\", strlen(prefix));\n    if (end != s.npos) {\n      \n      s.erase(strlen(\"std\"), end - strlen(\"std\"));\n    }\n  }\n  return s;\n}",
    "c_group_1_id_387": "inline uint32_t CreateCodePointFromUtf16SurrogatePair(wchar_t first,\n                                                      wchar_t second) {\n  const auto first_u = static_cast<uint32_t>(first);\n  const auto second_u = static_cast<uint32_t>(second);\n  const uint32_t mask = (1 << 10) - 1;\n  return (sizeof(wchar_t) == 2)\n             ? (((first_u & mask) << 10) | (second_u & mask)) + 0x10000\n             :\n             \n             \n             first_u;\n}",
    "c_group_1_id_388": "static ::std::string FormatDeathTestOutput(const ::std::string& output) {\n  ::std::string ret;\n  for (size_t at = 0; ; ) {\n    const size_t line_end = output.find('\\n', at);\n    ret += \"[  DEATH   ] \";\n    if (line_end == ::std::string::npos) {\n      ret += output.substr(at);\n      break;\n    }\n    ret += output.substr(at, line_end + 1 - at);\n    at = line_end + 1;\n  }\n  return ret;\n}",
    "c_group_1_id_394": "static const char* ParseGoogleMockFlagValue(const char* str,\n                                            const char* flag,\n                                            bool def_optional) {\n  \n  if (str == nullptr || flag == nullptr) return nullptr;\n\n  \n  const std::string flag_str = std::string(\"--gmock_\") + flag;\n  const size_t flag_len = flag_str.length();\n  if (strncmp(str, flag_str.c_str(), flag_len) != 0) return nullptr;\n\n  \n  const char* flag_end = str + flag_len;\n\n  \n  if (def_optional && (flag_end[0] == '\\0')) {\n    return flag_end;\n  }\n\n  \n  \n  \n  if (flag_end[0] != '=') return nullptr;\n\n  \n  return flag_end + 1;\n}",
    "c_group_1_id_396": "void test_len(size_t len1, size_t len2, size_t len3, size_t wide)\n{\n  std::string str1, str2, str3;\n  std::stringstream ss;\n  ss << len1 << \" \" << len2 << \" \" << len3;\n  ss >> str1 >> str2 >> str3;\n  str1 += \"   |\";\n  std::cout << std::setw(wide) << str1;\n  str2 += \"   |\";\n  std::cout << std::setw(wide) << str2;\n  str3 += \"   |\";\n  std::cout << std::setw(wide) << str3 << \"\\n\";\n}",
    "c_group_1_id_406": "static char *\nbazename(const char *fname)\n{\n\tstatic char buf[300];\n\tstrcpy(buf, fname);\n\treturn basename(buf);\n}",
    "c_group_1_id_409": "static inline unsigned lcp(unsigned char a, unsigned char b)\n{\n\tassert(a != b);\n\t(void)a;\n\t(void)b;\n\treturn 0;\n}",
    "c_group_1_id_413": "static char *\nstatus_entry(const char *key)\n{\n\tchar *result = NULL;\n\tchar *line = NULL;\n\tsize_t line_n = 0;\n\tFILE *fp;\n\tfp = fopen(\"/proc/self/status\", \"r\");\n\tif (!fp)\n\t\tgoto done;\n\twhile (getline(&line, &line_n, fp) != -1) {\n\t\tchar *v;\n\t\tv = strchr(line, ':');\n\t\tif (!v || *v == '\\0')\n\t\t\tcontinue;\n\t\t*v = '\\0';\n\t\tif (strcmp(line, key) != 0)\n\t\t\tcontinue;\n\t\t++v;\n\t\twhile (*v == ' ' || *v == '\\t')\n\t\t\t++v;\n\t\tif (strlen(v) > 1)\n\t\t\tv[strlen(v)-1] = '\\0';\n\t\tif (*v == '\\0')\n\t\t\tgoto done;\n\t\tresult = line;\n\t\twhile ((*line++ = *v++))\n\t\t\t;\n\t\tgoto done;\n\t}\ndone:\n\tif (!result)\n\t\tfree(line);\n\tif (fp)\n\t\tfclose(fp);\n\treturn result;\n}",
    "c_group_1_id_414": "static void\nadd_smaps(char *buf, char **pairs, unsigned pairs_cnt)\n{\n\tunsigned i, j;\n\tfor (i=0, j=pairs_cnt/2; i < pairs_cnt/2; ++i, ++j) {\n\t\tpairs[i][strlen(pairs[i])-1] = '\\0';\n\t\tstrcat(buf, \"    \");\n\t\tstrcat(buf, pairs[i]);\n\t\tstrcat(buf, \"  |  \");\n\t\tstrcat(buf, pairs[j]);\n\t}\n\tif (j < pairs_cnt) {\n\t\tstrcat(buf, \"    \");\n\t\tstrcat(buf, pairs[j]);\n\t}\n}",
    "c_group_1_id_415": "int dividebyN(int N) {\n\twhile (N%53 == 0) {\n\t\tN = N/53;\n\t}\n\twhile (N%47 == 0) {\n\t\tN = N/47;\n\t}\n\twhile (N%43 == 0) {\n\t\tN = N/43;\n\t}\n\twhile (N%41 == 0) {\n\t\tN = N/41;\n\t}\n\twhile (N%37 == 0) {\n\t\tN = N/37;\n\t}\n\twhile (N%31 == 0) {\n\t\tN = N/31;\n\t}\n\twhile (N%29 == 0) {\n\t\tN = N/29;\n\t}\n\twhile (N%23 == 0) {\n\t\tN = N/23;\n\t}\n\twhile (N%17 == 0) {\n\t\tN = N/17;\n\t}\n\twhile (N%13 == 0) {\n\t\tN = N/13;\n\t}\n\twhile (N%11 == 0) {\n\t\tN = N/11;\n\t}\n\twhile (N%8 == 0) {\n\t\tN = N/8;\n\t}\n\twhile (N%7 == 0) {\n\t\tN = N/7;\n\t}\n\twhile (N%5 == 0) {\n\t\tN = N/5;\n\t}\n\twhile (N%4 == 0) {\n\t\tN = N/4;\n\t}\n\twhile (N%3 == 0) {\n\t\tN = N/3;\n\t}\n\twhile (N%2 == 0) {\n\t\tN = N/2;\n\t}\n\tif (N == 1) {\n\t\treturn 1;\n\t}\n\t return 0;\n\n}",
    "c_group_1_id_416": "int factors(int M, int* arr) {\n\tint i,N,num,mult,m1,m2;\n\ti = 0;\n\tN = M;\n\twhile (N%53 == 0) {\n\t\tN = N/53;\n\t\tarr[i] = 53;\n\t\ti++;\n\t}\n\twhile (N%47 == 0) {\n\t\tN = N/47;\n\t\tarr[i] = 47;\n\t\ti++;\n\t}\n\twhile (N%43 == 0) {\n\t\tN = N/43;\n\t\tarr[i] = 43;\n\t\ti++;\n\t}\n\twhile (N%41 == 0) {\n\t\tN = N/41;\n\t\tarr[i] = 41;\n\t\ti++;\n\t}\n\twhile (N%37 == 0) {\n\t\tN = N/37;\n\t\tarr[i] = 37;\n\t\ti++;\n\t}\n\twhile (N%31 == 0) {\n\t\tN = N/31;\n\t\tarr[i] = 31;\n\t\ti++;\n\t}\n\twhile (N%29 == 0) {\n\t\tN = N/29;\n\t\tarr[i] = 29;\n\t\ti++;\n\t}\n\twhile (N%23 == 0) {\n\t\tN = N/23;\n\t\tarr[i] = 23;\n\t\ti++;\n\t}\n\twhile (N%19 == 0) {\n\t\tN = N/19;\n\t\tarr[i] = 19;\n\t\ti++;\n\t}\n\twhile (N%17 == 0) {\n\t\tN = N/17;\n\t\tarr[i] = 17;\n\t\ti++;\n\t}\n\twhile (N%13 == 0) {\n\t\tN = N/13;\n\t\tarr[i] = 13;\n\t\ti++;\n\t}\n\twhile (N%11 == 0) {\n\t\tN = N/11;\n\t\tarr[i] = 11;\n\t\ti++;\n\t}\n\twhile (N%8 == 0) {\n\t\tN = N/8;\n\t\tarr[i] = 8;\n\t\ti++;\n\t}\n\twhile (N%7 == 0) {\n\t\tN = N/7;\n\t\tarr[i] = 7;\n\t\ti++;\n\t}\n\twhile (N%5 == 0) {\n\t\tN = N/5;\n\t\tarr[i] = 5;\n\t\ti++;\n\t}\n\twhile (N%4 == 0) {\n\t\tN = N/4;\n\t\tarr[i] = 4;\n\t\ti++;\n\t}\n\twhile (N%3 == 0) {\n\t\tN = N/3;\n\t\tarr[i] = 3;\n\t\ti++;\n\t}\n\twhile (N%2 == 0) {\n\t\tN = N/2;\n\t\tarr[i] = 2;\n\t\ti++;\n\t}\n\tif (N > 31) {\n\t\tnum = 2;\n\n\t\twhile (N > 1) {\n\t\t\tmult = num*6;\n\t\t\tm1 = mult-1;\n\t\t\tm2 = mult+1;\n\t\t\twhile (N%m1 == 0 ) {\n\t\t\t\tarr[i] = m1;\n\t\t\t\ti++;\n\t\t\t\tN = N / m1;\n\t\t\t}\n\t\t\twhile (N%m2 == 0 ) {\n\t\t\t\tarr[i] = m2;\n\t\t\t\ti++;\n\t\t\t\tN = N / m2;\n\t\t\t}\n\t\t\tnum+=1;\n\n\t\t}\n\t}\n\treturn i;\n\n}",
    "c_group_1_id_417": "int factorf(int M) {\n\tint N;\n\tN = M;\n\twhile (N%7 == 0){\n\t\t\tN = N/7;\n\t\t}\n\twhile (N%3 == 0){\n\t\t\tN = N/3;\n\t\t}\n\twhile (N%5 == 0){\n\t\t\tN = N/5;\n\t\t}\n\twhile (N%2 == 0){\n\t\t\tN = N/2;\n\t\t}\n\n\treturn N;\n}",
    "c_group_1_id_423": "void\nsrc_short_to_float_array (const short *in, float *out, int len)\n{\n\tfor (int i = 0 ; i < len ; i++)\n\t{\tout [i] = (float) (in [i] / (1.0 * 0x8000)) ;\n\t\t} ;\n\n\treturn ;\n}",
    "c_group_1_id_424": "void\nsrc_int_to_float_array (const int *in, float *out, int len)\n{\n\tfor (int i = 0 ; i < len ; i++)\n\t{\tout [i] = (float) (in [i] / (8.0 * 0x10000000)) ;\n\t\t} ;\n\n\treturn ;\n}",
    "c_group_1_id_425": "double\ncalculate_snr (float *data, int len, int expected_peaks)\n{\tdouble snr = 200.0 ;\n\n\tdata = data ;\n\tlen = len ;\n\texpected_peaks = expected_peaks ;\n\n\treturn snr ;\n}",
    "c_group_1_id_426": "static void\nalarm_handler (int number)\n{\n\t(void) number ;\n\tprintf (\"\\n\\n    Error : Hang inside src_callback_read() detected. Exiting!\\n\\n\") ;\n\texit (1) ;\n}",
    "c_group_1_id_429": "const char* wolfSSL_ERR_func_error_string(unsigned long e)\n{\n    (void)e;\n    WOLFSSL_MSG(\"wolfSSL_ERR_func_error_string does not return the name of \"\n                \"the function that failed. Please inspect the wolfSSL debug \"\n                \"logs to determine where the error occurred.\");\n    return \"\";\n}",
    "c_group_1_id_432": "void SrpTest(void)\n{\n#if defined(WOLFCRYPT_HAVE_SRP) && defined(WOLFSSL_SHA512)\n    wolfCrypt_Init();\n    test_SrpInit();\n    test_SrpSetUsername();\n    test_SrpSetParams();\n#ifndef NO_SHA\n    test_SrpSetPassword();\n    test_SrpGetPublic();\n    test_SrpComputeKey();\n    test_SrpGetProofAndVerify();\n#endif \n    test_SrpKeyGenFunc_cb();\n    wolfCrypt_Cleanup();\n#endif\n}",
    "c_group_1_id_435": "static int test_wolfSSL_tls_export(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(WOLFSSL_SESSION_EXPORT) && !defined(WOLFSSL_NO_TLS12)\n    test_wolfSSL_tls_export_run(WOLFSSL_TLSV1_2);\n    #ifdef WOLFSSL_TLS13\n    test_wolfSSL_tls_export_run(WOLFSSL_TLSV1_3);\n    #endif\n    res = TEST_RES_CHECK(1);\n#endif\n\n    return res;\n}",
    "c_group_1_id_436": "static int test_wc_ecc_sm2_make_key(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(HAVE_ECC) && defined(WOLFSSL_SM2)\n    EXPECT_DECLS;\n    WC_RNG  rng[1];\n    ecc_key key[1];\n\n    XMEMSET(rng, 0, sizeof(*rng));\n    XMEMSET(key, 0, sizeof(*key));\n\n    ExpectIntEQ(wc_InitRng(rng), 0);\n    ExpectIntEQ(wc_ecc_init(key), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_make_key(NULL, NULL, WC_ECC_FLAG_NONE),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_make_key(rng, NULL, WC_ECC_FLAG_NONE),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_make_key(NULL, key, WC_ECC_FLAG_NONE),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_ecc_sm2_make_key(rng, key, WC_ECC_FLAG_NONE), 0);\n    ExpectIntEQ(key->dp->id, ECC_SM2P256V1);\n\n    wc_ecc_free(key);\n    wc_FreeRng(rng);\n#ifdef FP_ECC\n    wc_ecc_fp_free();\n#endif\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
    "c_group_1_id_437": "static int test_wc_ecc_sm2_shared_secret(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(HAVE_ECC) && defined(WOLFSSL_SM2)\n    EXPECT_DECLS;\n    WC_RNG  rng[1];\n    ecc_key keyA[1];\n    ecc_key keyB[1];\n    byte outA[32];\n    byte outB[32];\n    word32 outALen = 32;\n    word32 outBLen = 32;\n\n    XMEMSET(rng, 0, sizeof(*rng));\n    XMEMSET(keyA, 0, sizeof(*keyA));\n    XMEMSET(keyB, 0, sizeof(*keyB));\n\n    ExpectIntEQ(wc_InitRng(rng), 0);\n    ExpectIntEQ(wc_ecc_init(keyA), 0);\n    ExpectIntEQ(wc_ecc_init(keyB), 0);\n    ExpectIntEQ(wc_ecc_sm2_make_key(rng, keyA, WC_ECC_FLAG_NONE), 0);\n    ExpectIntEQ(wc_ecc_sm2_make_key(rng, keyB, WC_ECC_FLAG_NONE), 0);\n\n#ifdef ECC_TIMING_RESISTANT\n    ExpectIntEQ(wc_ecc_set_rng(keyA, rng), 0);\n    ExpectIntEQ(wc_ecc_set_rng(keyB, rng), 0);\n#endif\n\n    \n    ExpectIntEQ(wc_ecc_sm2_shared_secret(NULL, NULL, NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyA, NULL, NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(NULL, keyB, NULL, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(NULL, NULL, outA, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(NULL, NULL, NULL, &outALen),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(NULL, keyB, outA, &outALen),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyA, NULL, outA, &outALen),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyA, keyB, NULL, &outALen),\n        WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyA, keyB, outA, NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyA, keyB, outA, &outALen), 0);\n    ExpectIntLE(outALen, 32);\n    ExpectIntEQ(wc_ecc_sm2_shared_secret(keyB, keyA, outB, &outBLen), 0);\n    ExpectIntLE(outBLen, 32);\n    ExpectIntEQ(outALen, outBLen);\n    ExpectBufEQ(outA, outB, outALen);\n\n    wc_ecc_free(keyB);\n    wc_ecc_free(keyA);\n    wc_FreeRng(rng);\n#ifdef FP_ECC\n    wc_ecc_fp_free();\n#endif\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
    "c_group_1_id_438": "static int test_wc_ecc_sm2_create_digest(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(HAVE_ECC) && defined(WOLFSSL_SM2) && !defined(NO_HASH_WRAPPER) && \\\n    (defined(WOLFSSL_SM3) || !defined(NO_SHA256))\n    EXPECT_DECLS;\n    ecc_key key[1];\n    enum wc_HashType hashType;\n    unsigned char pub[] = {\n        0x04,\n        0x63, 0x7F, 0x1B, 0x13, 0x50, 0x36, 0xC9, 0x33,\n        0xDC, 0x3F, 0x7A, 0x8E, 0xBB, 0x1B, 0x7B, 0x2F,\n        0xD1, 0xDF, 0xBD, 0x26, 0x8D, 0x4F, 0x89, 0x4B,\n        0x5A, 0xD4, 0x7D, 0xBD, 0xBE, 0xCD, 0x55, 0x8F,\n        0xE8, 0x81, 0x01, 0xD0, 0x80, 0x48, 0xE3, 0x6C,\n        0xCB, 0xF6, 0x1C, 0xA3, 0x8D, 0xDF, 0x7A, 0xBA,\n        0x54, 0x2B, 0x44, 0x86, 0xE9, 0x9E, 0x49, 0xF3,\n        0xA7, 0x47, 0x0A, 0x85, 0x7A, 0x09, 0x64, 0x33\n    };\n    unsigned char id[] = {\n        0x01, 0x02, 0x03,\n    };\n    unsigned char msg[] = {\n        0x01, 0x02, 0x03,\n    };\n    unsigned char hash[32];\n#ifdef WOLFSSL_SM3\n    unsigned char expHash[32] = {\n        0xc1, 0xdd, 0x92, 0xc5, 0x60, 0xd3, 0x94, 0x28,\n        0xeb, 0x0f, 0x57, 0x79, 0x3f, 0xc9, 0x96, 0xc5,\n        0xfa, 0xf5, 0x90, 0xb2, 0x64, 0x2f, 0xaf, 0x9c,\n        0xc8, 0x57, 0x21, 0x6a, 0x52, 0x7e, 0xf1, 0x95\n    };\n#else\n    unsigned char expHash[32] = {\n        0xea, 0x41, 0x55, 0x21, 0x61, 0x00, 0x5c, 0x9a,\n        0x57, 0x35, 0x6b, 0x49, 0xca, 0x8f, 0x65, 0xc2,\n        0x0e, 0x29, 0x0c, 0xa0, 0x1d, 0xa7, 0xc4, 0xed,\n        0xdd, 0x51, 0x12, 0xf6, 0xe7, 0x55, 0xc5, 0xf4\n    };\n#endif\n\n#ifdef WOLFSSL_SM3\n    hashType = WC_HASH_TYPE_SM3;\n#else\n    hashType = WC_HASH_TYPE_SHA256;\n#endif\n\n    XMEMSET(key, 0, sizeof(*key));\n\n    ExpectIntEQ(wc_ecc_init(key), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        hashType, hash, sizeof(hash), key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    ExpectIntEQ(wc_ecc_import_x963_ex(pub, sizeof(pub), key, ECC_SM2P256V1), 0);\n\n    \n    ExpectIntEQ(wc_ecc_sm2_create_digest(NULL, sizeof(id), NULL, sizeof(msg),\n        hashType, NULL, sizeof(hash), NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), NULL, sizeof(msg),\n        hashType, NULL, sizeof(hash), NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(NULL, sizeof(id), msg, sizeof(msg),\n        hashType, NULL, sizeof(hash), NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(NULL, sizeof(id), NULL, sizeof(msg),\n        hashType, hash, sizeof(hash), NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(NULL, sizeof(id), NULL, sizeof(msg),\n        hashType, NULL, sizeof(hash), key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(NULL, sizeof(id), msg, sizeof(msg),\n        hashType, hash, sizeof(hash), key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), NULL, sizeof(msg),\n        hashType, hash, sizeof(hash), key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        hashType, NULL, sizeof(hash), key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        hashType, hash, sizeof(hash), NULL), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n\n    \n    \n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        -1, hash, 0, key), WC_NO_ERR_TRACE(BAD_FUNC_ARG));\n    \n    \n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        hashType, hash, 0, key), WC_NO_ERR_TRACE(BUFFER_E));\n\n    \n    ExpectIntEQ(wc_ecc_sm2_create_digest(id, sizeof(id), msg, sizeof(msg),\n        hashType, hash, sizeof(hash), key), 0);\n    ExpectBufEQ(hash, expHash, sizeof(expHash));\n\n    wc_ecc_free(key);\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
    "c_group_1_id_439": "static int test_wolfSSL_X509_STORE_CTX_trusted_stack_cleanup(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n    X509_STORE_CTX_cleanup(NULL);\n    X509_STORE_CTX_trusted_stack(NULL, NULL);\n\n    res = TEST_SUCCESS;\n#endif\n    return res;\n}",
    "c_group_1_id_440": "static int test_error_queue_per_thread(void)\n{\n    int res = TEST_SKIPPED;\n#if !defined(SINGLE_THREADED) && defined(ERROR_QUEUE_PER_THREAD) && \\\n    !defined(NO_ERROR_QUEUE) && defined(OPENSSL_EXTRA) && \\\n    defined(DEBUG_WOLFSSL)\n    THREAD_TYPE loggingThreads[LOGGING_THREADS];\n    int i;\n\n    ERR_clear_error(); \n\n    loggingThreadsReady = 0;\n    for (i = 0; i < LOGGING_THREADS; i++)\n        start_thread(test_logging, NULL, &loggingThreads[i]);\n    loggingThreadsReady = 1;\n    for (i = 0; i < LOGGING_THREADS; i++)\n        join_thread(loggingThreads[i]);\n\n    res = TEST_SUCCESS;\n#endif\n    return res;\n}",
    "c_group_1_id_441": "static int test_WOLFSSL_ERROR_MSG(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(DEBUG_WOLFSSL) || defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) ||\\\n    defined(WOLFSSL_HAPROXY) || defined(OPENSSL_EXTRA)\n    const char* msg = TEST_STRING;\n\n    WOLFSSL_ERROR_MSG(msg);\n\n    res = TEST_SUCCESS;\n#endif\n    return res;\n}",
    "c_group_1_id_442": "static int test_wc_ERR_remove_state(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE)\n    wc_ERR_remove_state();\n\n    res = TEST_SUCCESS;\n#endif\n    return res;\n}",
    "c_group_1_id_443": "static int test_ERR_load_crypto_strings(void)\n{\n#if defined(OPENSSL_ALL)\n    ERR_load_crypto_strings();\n    return TEST_SUCCESS;\n#else\n    return TEST_SKIPPED;\n#endif\n}",
    "c_group_1_id_444": "static int test_wolfssl_EVP_aria_gcm(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(HAVE_ARIA) && \\\n    !defined(HAVE_SELFTEST) && !defined(HAVE_FIPS)\n\n    \n    byte *key = (byte*)\"01234567890123456789012345678901\";\n    \n    byte *iv = (byte*)\"0123456789012345\";\n    int ivSz = ARIA_BLOCK_SIZE;\n    \n    const int plaintxtSz = 40;\n    byte plaintxt[WC_ARIA_GCM_GET_CIPHERTEXT_SIZE(plaintxtSz)];\n    XMEMCPY(plaintxt,\"for things to change you have to change\",plaintxtSz);\n    \n    byte *aad = (byte*)\"Don't spend major time on minor things.\";\n\n    unsigned char tag[ARIA_BLOCK_SIZE] = {0};\n    int aadSz = (int)XSTRLEN((char*)aad);\n    byte ciphertxt[WC_ARIA_GCM_GET_CIPHERTEXT_SIZE(plaintxtSz)];\n    byte decryptedtxt[plaintxtSz];\n    int ciphertxtSz = 0;\n    int decryptedtxtSz = 0;\n    int len = 0;\n    int i = 0;\n    #define TEST_ARIA_GCM_COUNT 6\n    EVP_CIPHER_CTX en[TEST_ARIA_GCM_COUNT];\n    EVP_CIPHER_CTX de[TEST_ARIA_GCM_COUNT];\n\n    for (i = 0; i < TEST_ARIA_GCM_COUNT; i++) {\n\n        EVP_CIPHER_CTX_init(&en[i]);\n        switch (i) {\n            case 0:\n                \n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_128_gcm(), NULL, key, iv));\n                break;\n            case 1:\n                \n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_192_gcm(), NULL, key, iv));\n                break;\n            case 2:\n                \n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_256_gcm(), NULL, key, iv));\n                break;\n            case 3:\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_128_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], NULL, NULL, key, iv));\n                break;\n            case 4:\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_192_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], NULL, NULL, key, iv));\n                break;\n            case 5:\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_aria_256_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_EncryptInit_ex(&en[i], NULL, NULL, key, iv));\n                break;\n        }\n        XMEMSET(ciphertxt,0,sizeof(ciphertxt));\n        AssertIntEQ(1, EVP_EncryptUpdate(&en[i], NULL, &len, aad, aadSz));\n        AssertIntEQ(1, EVP_EncryptUpdate(&en[i], ciphertxt, &len, plaintxt, plaintxtSz));\n        ciphertxtSz = len;\n        AssertIntEQ(1, EVP_EncryptFinal_ex(&en[i], ciphertxt, &len));\n        AssertIntNE(0, XMEMCMP(plaintxt, ciphertxt, plaintxtSz));\n        ciphertxtSz += len;\n        AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_GET_TAG, ARIA_BLOCK_SIZE, tag));\n        AssertIntEQ(wolfSSL_EVP_CIPHER_CTX_cleanup(&en[i]), 1);\n\n        EVP_CIPHER_CTX_init(&de[i]);\n        switch (i) {\n            case 0:\n                \n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_128_gcm(), NULL, key, iv));\n                break;\n            case 1:\n                \n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_192_gcm(), NULL, key, iv));\n                break;\n            case 2:\n                \n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_256_gcm(), NULL, key, iv));\n                break;\n            case 3:\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_128_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], NULL, NULL, key, iv));\n                break;\n            case 4:\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_192_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], NULL, NULL, key, iv));\n                break;\n            case 5:\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_aria_256_gcm(), NULL, NULL, NULL));\n                \n                AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n                AssertIntEQ(1, EVP_DecryptInit_ex(&de[i], NULL, NULL, key, iv));\n                break;\n        }\n        XMEMSET(decryptedtxt,0,sizeof(decryptedtxt));\n        AssertIntEQ(1, EVP_DecryptUpdate(&de[i], NULL, &len, aad, aadSz));\n        AssertIntEQ(1, EVP_DecryptUpdate(&de[i], decryptedtxt, &len, ciphertxt, ciphertxtSz));\n        decryptedtxtSz = len;\n        AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_TAG, ARIA_BLOCK_SIZE, tag));\n        AssertIntEQ(1, EVP_DecryptFinal_ex(&de[i], decryptedtxt, &len));\n        decryptedtxtSz += len;\n        AssertIntEQ(plaintxtSz, decryptedtxtSz);\n        AssertIntEQ(0, XMEMCMP(plaintxt, decryptedtxt, decryptedtxtSz));\n\n        XMEMSET(decryptedtxt,0,sizeof(decryptedtxt));\n        \n        tag[AES_BLOCK_SIZE-1]+=0xBB;\n        AssertIntEQ(1, EVP_DecryptUpdate(&de[i], NULL, &len, aad, aadSz));\n        AssertIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_TAG, ARIA_BLOCK_SIZE, tag));\n        \n        AssertIntEQ(1, EVP_DecryptUpdate(&de[i], decryptedtxt, &len, ciphertxt, ciphertxtSz));\n        AssertIntEQ(0, EVP_DecryptFinal_ex(&de[i], decryptedtxt, &len));\n        AssertIntEQ(0, len);\n        AssertIntEQ(wolfSSL_EVP_CIPHER_CTX_cleanup(&de[i]), 1);\n    }\n\n    res = TEST_RES_CHECK(1);\n#endif \n    return res;\n}",
    "c_group_1_id_445": "static int test_wolfssl_EVP_sm4_gcm_zeroLen(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_SM4_GCM)\n    \n    EXPECT_DECLS;\n    byte key[] = {\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n    }; \n    byte iv[]  = {\n        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n    }; \n    byte plaintxt[1];\n    int ivSz  = 12;\n    int plaintxtSz = 0;\n    unsigned char tag[16];\n    unsigned char tag_kat[16] = {\n        0x23,0x2f,0x0c,0xfe,0x30,0x8b,0x49,0xea,\n        0x6f,0xc8,0x82,0x29,0xb5,0xdc,0x85,0x8d\n    };\n\n    byte ciphertxt[SM4_BLOCK_SIZE * 4] = {0};\n    byte decryptedtxt[SM4_BLOCK_SIZE * 4] = {0};\n    int ciphertxtSz = 0;\n    int decryptedtxtSz = 0;\n    int len = 0;\n\n    EVP_CIPHER_CTX *en = EVP_CIPHER_CTX_new();\n    EVP_CIPHER_CTX *de = EVP_CIPHER_CTX_new();\n\n    ExpectIntEQ(1, EVP_EncryptInit_ex(en, EVP_sm4_gcm(), NULL, key, iv));\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(en, EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n    ExpectIntEQ(1, EVP_EncryptUpdate(en, ciphertxt, &ciphertxtSz , plaintxt,\n        plaintxtSz));\n    ExpectIntEQ(1, EVP_EncryptFinal_ex(en, ciphertxt, &len));\n    ciphertxtSz += len;\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(en, EVP_CTRL_GCM_GET_TAG, 16, tag));\n    ExpectIntEQ(1, EVP_CIPHER_CTX_cleanup(en));\n\n    ExpectIntEQ(0, ciphertxtSz);\n    ExpectIntEQ(0, XMEMCMP(tag, tag_kat, sizeof(tag)));\n\n    EVP_CIPHER_CTX_init(de);\n    ExpectIntEQ(1, EVP_DecryptInit_ex(de, EVP_sm4_gcm(), NULL, key, iv));\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(de, EVP_CTRL_GCM_SET_IVLEN, ivSz, NULL));\n    ExpectIntEQ(1, EVP_DecryptUpdate(de, NULL, &len, ciphertxt, len));\n    decryptedtxtSz = len;\n    ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(de, EVP_CTRL_GCM_SET_TAG, 16, tag));\n    ExpectIntEQ(1, EVP_DecryptFinal_ex(de, decryptedtxt, &len));\n    decryptedtxtSz += len;\n    ExpectIntEQ(0, decryptedtxtSz);\n\n    EVP_CIPHER_CTX_free(en);\n    EVP_CIPHER_CTX_free(de);\n\n    res = EXPECT_RESULT();\n#endif \n    return res;\n}",
    "c_group_1_id_446": "static int test_wolfssl_EVP_sm4_gcm(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_SM4_GCM)\n    EXPECT_DECLS;\n    byte *key = (byte*)\"0123456789012345\";\n    \n    byte *iv = (byte*)\"0123456789012345\";\n    int ivSz = SM4_BLOCK_SIZE;\n    \n    byte *plaintxt = (byte*)\"for things to change you have to change\";\n    \n    byte *aad = (byte*)\"Don't spend major time on minor things.\";\n\n    unsigned char tag[SM4_BLOCK_SIZE] = {0};\n    int plaintxtSz = (int)XSTRLEN((char*)plaintxt);\n    int aadSz = (int)XSTRLEN((char*)aad);\n    byte ciphertxt[SM4_BLOCK_SIZE * 4] = {0};\n    byte decryptedtxt[SM4_BLOCK_SIZE * 4] = {0};\n    int ciphertxtSz = 0;\n    int decryptedtxtSz = 0;\n    int len = 0;\n    int i = 0;\n    EVP_CIPHER_CTX en[2];\n    EVP_CIPHER_CTX de[2];\n\n    for (i = 0; i < 2; i++) {\n        EVP_CIPHER_CTX_init(&en[i]);\n\n        if (i == 0) {\n            \n            ExpectIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_sm4_gcm(), NULL, key,\n                iv));\n        }\n        else {\n            ExpectIntEQ(1, EVP_EncryptInit_ex(&en[i], EVP_sm4_gcm(), NULL, NULL,\n                NULL));\n             \n            ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_SET_IVLEN,\n                ivSz, NULL));\n            ExpectIntEQ(1, EVP_EncryptInit_ex(&en[i], NULL, NULL, key, iv));\n        }\n        ExpectIntEQ(1, EVP_EncryptUpdate(&en[i], NULL, &len, aad, aadSz));\n        ExpectIntEQ(1, EVP_EncryptUpdate(&en[i], ciphertxt, &len, plaintxt,\n            plaintxtSz));\n        ciphertxtSz = len;\n        ExpectIntEQ(1, EVP_EncryptFinal_ex(&en[i], ciphertxt, &len));\n        ciphertxtSz += len;\n        ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(&en[i], EVP_CTRL_GCM_GET_TAG,\n            SM4_BLOCK_SIZE, tag));\n        ExpectIntEQ(wolfSSL_EVP_CIPHER_CTX_cleanup(&en[i]), 1);\n\n        EVP_CIPHER_CTX_init(&de[i]);\n        if (i == 0) {\n            \n            ExpectIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_sm4_gcm(), NULL, key,\n                iv));\n        }\n        else {\n            ExpectIntEQ(1, EVP_DecryptInit_ex(&de[i], EVP_sm4_gcm(), NULL, NULL,\n                NULL));\n            \n            ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_IVLEN,\n                ivSz, NULL));\n            ExpectIntEQ(1, EVP_DecryptInit_ex(&de[i], NULL, NULL, key, iv));\n\n        }\n        ExpectIntEQ(1, EVP_DecryptUpdate(&de[i], NULL, &len, aad, aadSz));\n        ExpectIntEQ(1, EVP_DecryptUpdate(&de[i], decryptedtxt, &len, ciphertxt,\n            ciphertxtSz));\n        decryptedtxtSz = len;\n        ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_TAG,\n            SM4_BLOCK_SIZE, tag));\n        ExpectIntEQ(1, EVP_DecryptFinal_ex(&de[i], decryptedtxt, &len));\n        decryptedtxtSz += len;\n        ExpectIntEQ(ciphertxtSz, decryptedtxtSz);\n        ExpectIntEQ(0, XMEMCMP(plaintxt, decryptedtxt, decryptedtxtSz));\n\n        \n        tag[SM4_BLOCK_SIZE-1]+=0xBB;\n        ExpectIntEQ(1, EVP_DecryptUpdate(&de[i], NULL, &len, aad, aadSz));\n        ExpectIntEQ(1, EVP_CIPHER_CTX_ctrl(&de[i], EVP_CTRL_GCM_SET_TAG,\n            SM4_BLOCK_SIZE, tag));\n        \n        ExpectIntEQ(1, EVP_DecryptUpdate(&de[i], decryptedtxt, &len, ciphertxt,\n            ciphertxtSz));\n        ExpectIntEQ(0, EVP_DecryptFinal_ex(&de[i], decryptedtxt, &len));\n        ExpectIntEQ(0, len);\n        ExpectIntEQ(wolfSSL_EVP_CIPHER_CTX_cleanup(&de[i]), 1);\n    }\n\n    res = EXPECT_RESULT();\n#endif \n    return res;\n}",
    "c_group_1_id_447": "static int test_wolfSSL_dup_CA_list(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_ALL)\n    EXPECT_DECLS;\n    STACK_OF(X509_NAME) *originalStack = NULL;\n    STACK_OF(X509_NAME) *copyStack = NULL;\n    int originalCount = 0;\n    int copyCount = 0;\n    X509_NAME *name = NULL;\n    int i;\n\n    originalStack = sk_X509_NAME_new_null();\n    ExpectNotNull(originalStack);\n\n    for (i = 0; i < 3; i++) {\n        name = X509_NAME_new();\n        ExpectNotNull(name);\n        ExpectIntEQ(sk_X509_NAME_push(originalStack, name), i+1);\n        if (EXPECT_FAIL()) {\n            X509_NAME_free(name);\n        }\n    }\n\n    copyStack = SSL_dup_CA_list(originalStack);\n    ExpectNotNull(copyStack);\n    ExpectIntEQ(sk_X509_NAME_num(NULL), BAD_FUNC_ARG);\n    originalCount = sk_X509_NAME_num(originalStack);\n    copyCount = sk_X509_NAME_num(copyStack);\n\n    ExpectIntEQ(originalCount, copyCount);\n    sk_X509_NAME_pop_free(originalStack, X509_NAME_free);\n    sk_X509_NAME_pop_free(copyStack, X509_NAME_free);\n\n    originalStack = NULL;\n    copyStack = NULL;\n\n    originalStack = sk_X509_NAME_new_null();\n    ExpectNull(sk_X509_NAME_pop(NULL));\n    ExpectNull(sk_X509_NAME_pop(originalStack));\n    for (i = 0; i < 3; i++) {\n        name = X509_NAME_new();\n        ExpectNotNull(name);\n        ExpectIntEQ(sk_X509_NAME_push(originalStack, name), i+1);\n        if (EXPECT_FAIL()) {\n            X509_NAME_free(name);\n        }\n        name = NULL;\n    }\n    ExpectNotNull(name = sk_X509_NAME_pop(originalStack));\n    X509_NAME_free(name);\n    wolfSSL_sk_X509_NAME_set_cmp_func(NULL, NULL);\n    wolfSSL_sk_X509_NAME_set_cmp_func(originalStack, NULL);\n    wolfSSL_sk_X509_NAME_pop_free(originalStack, X509_NAME_free);\n\n    res = EXPECT_RESULT();\n#endif \n    return res;\n}",
    "c_group_1_id_448": "static int test_CONF_modules_xxx(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n    CONF_modules_free();\n\n    CONF_modules_unload(0);\n    CONF_modules_unload(1);\n    CONF_modules_unload(-1);\n\n    res = TEST_SUCCESS;\n#endif \n    return res;\n}",
    "c_group_1_id_449": "static int test_CRYPTO_set_dynlock_xxx(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n    CRYPTO_set_dynlock_create_callback(\n        (struct CRYPTO_dynlock_value *(*)(const char*, int))NULL);\n\n    CRYPTO_set_dynlock_create_callback(\n        (struct CRYPTO_dynlock_value *(*)(const char*, int))1);\n\n    CRYPTO_set_dynlock_destroy_callback(\n        (void (*)(struct CRYPTO_dynlock_value*, const char*, int))NULL);\n\n    CRYPTO_set_dynlock_destroy_callback(\n        (void (*)(struct CRYPTO_dynlock_value*, const char*, int))1);\n\n    CRYPTO_set_dynlock_lock_callback(\n        (void (*)(int, struct CRYPTO_dynlock_value *, const char*, int))NULL);\n\n    CRYPTO_set_dynlock_lock_callback(\n        (void (*)(int, struct CRYPTO_dynlock_value *, const char*, int))1);\n\n    res = TEST_SUCCESS;\n#endif \n    return res;\n}",
    "c_group_1_id_450": "static int test_ENGINE_cleanup(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n    ENGINE_cleanup();\n\n    res = TEST_SUCCESS;\n#endif \n    return res;\n}",
    "c_group_1_id_458": "static int test_wolfSSL_EVP_sm3(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA) && defined(WOLFSSL_SM3)\n    EXPECT_DECLS;\n    const EVP_MD* md = NULL;\n    EVP_MD_CTX* mdCtx = NULL;\n    byte data[WC_SM3_BLOCK_SIZE * 4];\n    byte hash[WC_SM3_DIGEST_SIZE];\n    byte calcHash[WC_SM3_DIGEST_SIZE];\n    byte expHash[WC_SM3_DIGEST_SIZE] = {\n        0x38, 0x48, 0x15, 0xa7, 0x0e, 0xae, 0x0b, 0x27,\n        0x5c, 0xde, 0x9d, 0xa5, 0xd1, 0xa4, 0x30, 0xa1,\n        0xca, 0xd4, 0x54, 0x58, 0x44, 0xa2, 0x96, 0x1b,\n        0xd7, 0x14, 0x80, 0x3f, 0x80, 0x1a, 0x07, 0xb6\n    };\n    word32 chunk;\n    word32 i;\n    unsigned int sz;\n    int ret;\n\n    XMEMSET(data, 0, sizeof(data));\n\n    md = EVP_sm3();\n    ExpectTrue(md != NULL);\n    ExpectIntEQ(XSTRNCMP(md, \"SM3\", XSTRLEN(\"SM3\")), 0);\n    mdCtx = EVP_MD_CTX_new();\n    ExpectTrue(mdCtx != NULL);\n\n    \n    ExpectIntEQ(EVP_DigestInit(NULL, md), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    \n    ExpectIntEQ(EVP_DigestInit(mdCtx, md), WOLFSSL_SUCCESS);\n\n    ExpectIntEQ(EVP_DigestUpdate(NULL, NULL, 1), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, NULL, 1), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestUpdate(NULL, data, 1), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n\n    \n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, NULL, 0), WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, 1), WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, 1), WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, WC_SM3_BLOCK_SIZE),\n        WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, WC_SM3_BLOCK_SIZE - 2),\n        WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, WC_SM3_BLOCK_SIZE * 2),\n        WOLFSSL_SUCCESS);\n    \n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, WC_SM3_PAD_SIZE),\n        WOLFSSL_SUCCESS);\n\n    \n    ExpectIntEQ(EVP_DigestFinal(NULL, NULL, NULL), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestFinal(mdCtx, NULL, NULL), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestFinal(NULL, hash, NULL), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestFinal(NULL, hash, NULL), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n    ExpectIntEQ(EVP_DigestFinal(mdCtx, NULL, NULL), WC_NO_ERR_TRACE(WOLFSSL_FAILURE));\n\n    \n    ExpectIntEQ(EVP_DigestFinal(mdCtx, hash, NULL), WOLFSSL_SUCCESS);\n    ExpectBufEQ(hash, expHash, WC_SM3_DIGEST_SIZE);\n\n    \n    ExpectIntEQ(EVP_DigestUpdate(mdCtx, data, sizeof(data)), WOLFSSL_SUCCESS);\n    ExpectIntEQ(EVP_DigestFinal(mdCtx, calcHash, &sz), WOLFSSL_SUCCESS);\n    ExpectIntEQ(sz, WC_SM3_DIGEST_SIZE);\n    for (chunk = 1; chunk <= WC_SM3_BLOCK_SIZE + 1; chunk++) {\n        for (i = 0; i + chunk <= (word32)sizeof(data); i += chunk) {\n            ExpectIntEQ(EVP_DigestUpdate(mdCtx, data + i, chunk),\n                WOLFSSL_SUCCESS);\n        }\n        if (i < (word32)sizeof(data)) {\n            ExpectIntEQ(EVP_DigestUpdate(mdCtx, data + i,\n                (word32)sizeof(data) - i), WOLFSSL_SUCCESS);\n        }\n        ExpectIntEQ(EVP_DigestFinal(mdCtx, hash, NULL), WOLFSSL_SUCCESS);\n        ExpectBufEQ(hash, calcHash, WC_SM3_DIGEST_SIZE);\n    }\n\n    \n\n    ret = EVP_MD_CTX_cleanup(mdCtx);\n    ExpectIntEQ(ret, WOLFSSL_SUCCESS);\n    wolfSSL_EVP_MD_CTX_free(mdCtx);\n\n    res = EXPECT_RESULT();\n#endif\n    return res;\n}",
    "c_group_1_id_459": "static int test_EVP_MD_do_all(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n    EVP_MD_do_all(NULL, stderr);\n\n    EVP_MD_do_all(list_md_fn, stderr);\n\n    res = TEST_SUCCESS;\n#endif\n\n    return res;\n}",
    "c_group_1_id_460": "static int test_OBJ_NAME_do_all(void)\n{\n    int res = TEST_SKIPPED;\n#if defined(OPENSSL_EXTRA)\n\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_MD_METH, NULL, NULL);\n\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_CIPHER_METH, NULL, stderr);\n\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_MD_METH, obj_name_t, stderr);\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_PKEY_METH, obj_name_t, stderr);\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_COMP_METH, obj_name_t, stderr);\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_NUM, obj_name_t, stderr);\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_UNDEF, obj_name_t, stderr);\n    OBJ_NAME_do_all(OBJ_NAME_TYPE_CIPHER_METH, obj_name_t, stderr);\n    OBJ_NAME_do_all(-1, obj_name_t, stderr);\n\n    res = TEST_SUCCESS;\n#endif\n\n    return res;\n}",
    "c_group_1_id_481": "static void TestCleanup(void)\n{\n#if defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE)\n    \n    wolfSSL_ERR_clear_error();\n#endif \n}",
    "c_group_1_id_482": "static int GetTlsVersion(const char* line)\n{\n    int version = -1;\n    const char* find = \"-v \";\n    const char* begin = strstr(line, find);\n\n    if (begin) {\n        begin += 3;\n        if (*begin == 'd' || *begin == 'e')\n            begin += 2;\n\n        version = atoi(begin);\n    }\n    return version;\n}",
    "c_group_1_id_483": "static time_t time_cb(time_t* t)\n{\n    if (t != NULL) {\n        *t = 99;\n    }\n\n    return 99;\n}",
    "c_group_1_id_484": "static WC_INLINE int bench_async_check(int* ret, void* asyncDev,\n        int callAgain, int* times, int limit, int* pending)\n    {\n        (void)ret;\n        (void)asyncDev;\n        (void)callAgain;\n        (void)times;\n        (void)limit;\n        (void)pending;\n\n        return 1;\n    }",
    "c_group_1_id_485": "static WC_INLINE int bench_async_handle(int* ret, void* asyncDev,\n        int callAgain, int* times, int* pending)\n    {\n        (void)asyncDev;\n        (void)callAgain;\n        (void)pending;\n\n        if (*ret >= 0) {\n            \n            (*times)++;\n            return 1;\n        }\n        return 0;\n    }",
    "c_group_1_id_486": "constexpr auto digits2(size_t value) -> const char* {\n  \n  return &\"0001020304050607080910111213141516171819\"\n         \"2021222324252627282930313233343536373839\"\n         \"4041424344454647484950515253545556575859\"\n         \"6061626364656667686970717273747576777879\"\n         \"8081828384858687888990919293949596979899\"[value * 2];\n}",
    "c_group_1_id_491": "std::string toString( char value ) {\n    if ( value == '\\r' )\n        return \"'\\\\r'\";\n    if ( value == '\\f' )\n        return \"'\\\\f'\";\n    if ( value == '\\n' )\n        return \"'\\\\n'\";\n    if ( value == '\\t' )\n        return \"'\\\\t'\";\n    if ( '\\0' <= value && value < ' ' )\n        return toString( static_cast<unsigned int>( value ) );\n    char chstr[] = \"' '\";\n    chstr[1] = value;\n    return chstr;\n}",
    "c_group_1_id_496": "void reduce_add(void* e1, void* e2, void* result)\n{\n    int el1 = e1 ? *((int*)e1) : 0;\n    int el2 = e2 ? *((int*)e2) : 0;\n    *((int*)result) = el1 + el2;\n}",
    "c_group_1_id_498": "void sum_reduce(void* e1, void* e2, void* res)\n{\n    int i = *(int*)e1;\n    int j = *(int*)e2;\n\n    *(int*)res = i + j;\n}",
    "c_group_1_id_499": "static int cmp_k(const void* k1, const void* k2)\n{\n    char* key1 = (char*)k1;\n    char* key2 = (char*)k2;\n    int i;\n    for (i = 0; i < (sizeof(int) * 7); i++) {\n        if (*key1 != *key2)\n            return 1;\n        key1++;\n        key2++;\n    }\n    return 0;\n}",
    "c_group_1_id_500": "size_t get_latin1_7bit_prefix_length(const uint8_t* data, size_t size)\n\t{\n\t\tfor (size_t i = 0; i < size; ++i)\n\t\t\tif (data[i] > 127)\n\t\t\t\treturn i;\n\n\t\treturn size;\n\t}",
    "c_group_1_id_503": "inline\nvoid\nparse_value(const std::string& text, std::string& value)\n{\n  value = text;\n}",
    "c_group_1_id_505": "static int\nis_left(int a)\n{\n  if (a == ANCR_END_BUF  || a == ANCR_SEMI_END_BUF ||\n      a == ANCR_END_LINE || a == ANCR_PREC_READ || a == ANCR_PREC_READ_NOT)\n    return 0;\n\n  return 1;\n}",
    "c_group_1_id_507": "static inline uint32_t ctz32(uint32_t n);\nstatic inline uint32_t ctz32(uint32_t n) {\n#if defined(__GNUC__) && UINT_MAX >= UINT32_MAX\n  return static_cast<uint32_t>(__builtin_ctz(n));\n\n#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))\n  uint32_t i;\n  __asm__(\"bsfl %1, %0\" : \"=r\"(i) : \"rm\"(n));\n  return i;\n\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\n  uint32_t i;\n  _BitScanForward((unsigned long *)&i, n);\n  return i;\n\n#else\n  uint32_t i = 1;\n\n  if ((n & static_cast<uint32_t>(0x0000FFFF)) == 0) {\n    n >>= 16;\n    i += 16;\n  }\n\n  if ((n & static_cast<uint32_t>(0x000000FF)) == 0) {\n    n >>= 8;\n    i += 8;\n  }\n\n  if ((n & static_cast<uint32_t>(0x0000000F)) == 0) {\n    n >>= 4;\n    i += 4;\n  }\n\n  if ((n & static_cast<uint32_t>(0x00000003)) == 0) {\n    n >>= 2;\n    i += 2;\n  }\n\n  i -= (n & 1);\n\n  return i;\n#endif\n}",
    "c_group_1_id_508": "static inline uint32_t ctz16(uint16_t n);\nstatic inline uint32_t ctz16(uint16_t n) {\n#if defined(__GNUC__) && UINT_MAX >= UINT32_MAX\n  return static_cast<uint32_t>(__builtin_ctz(n));\n\n#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))\n  uint32_t i;\n  __asm__(\"bsfl %1, %0\" : \"=r\"(i) : \"rm\"(n));\n  return i;\n\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\n  uint32_t i;\n  _BitScanForward((unsigned long *)&i, n);\n  return i;\n\n#else\n  uint32_t i = 1;\n\n  if ((n & static_cast<uint16_t>(0x000000FF)) == 0) {\n    n >>= 8;\n    i += 8;\n  }\n\n  if ((n & static_cast<uint16_t>(0x0000000F)) == 0) {\n    n >>= 4;\n    i += 4;\n  }\n\n  if ((n & static_cast<uint16_t>(0x00000003)) == 0) {\n    n >>= 2;\n    i += 2;\n  }\n  i -= (n & 1);\n\n  return i;\n#endif\n}",
    "c_group_1_id_509": "CGLM_INLINE\nfloat\nglm_ease_quad_in(float t);\nCGLM_INLINE\nfloat\nglm_ease_quad_in(float t) {\n  return t * t;\n}",
    "c_group_1_id_510": "CGLM_INLINE\nfloat\nglm_ease_quad_out(float t);\nCGLM_INLINE\nfloat\nglm_ease_quad_out(float t) {\n  return -(t * (t - 2.0f));\n}",
    "c_group_1_id_511": "CGLM_INLINE\nfloat\nglm_ease_quad_inout(float t);\nCGLM_INLINE\nfloat\nglm_ease_quad_inout(float t) {\n  float tt;\n\n  tt = t * t;\n  if (t < 0.5f)\n    return 2.0f * tt;\n\n  return (-2.0f * tt) + (4.0f * t) - 1.0f;\n}",
    "c_group_1_id_512": "CGLM_INLINE\nfloat\nglm_ease_cubic_in(float t);\nCGLM_INLINE\nfloat\nglm_ease_cubic_in(float t) {\n  return t * t * t;\n}",
    "c_group_1_id_513": "CGLM_INLINE\nfloat\nglm_ease_cubic_out(float t);\nCGLM_INLINE\nfloat\nglm_ease_cubic_out(float t) {\n  float f;\n  f = t - 1.0f;\n  return f * f * f + 1.0f;\n}",
    "c_group_1_id_514": "CGLM_INLINE\nfloat\nglm_ease_cubic_inout(float t);\nCGLM_INLINE\nfloat\nglm_ease_cubic_inout(float t) {\n  float f;\n\n  if (t < 0.5f)\n    return 4.0f * t * t * t;\n\n  f = 2.0f * t - 2.0f;\n\n  return 0.5f * f * f * f + 1.0f;\n}",
    "c_group_1_id_515": "CGLM_INLINE\nfloat\nglm_ease_quart_in(float t);\nCGLM_INLINE\nfloat\nglm_ease_quart_in(float t) {\n  float f;\n  f = t * t;\n  return f * f;\n}",
    "c_group_1_id_516": "CGLM_INLINE\nfloat\nglm_ease_quart_out(float t);\nCGLM_INLINE\nfloat\nglm_ease_quart_out(float t) {\n  float f;\n\n  f = t - 1.0f;\n\n  return f * f * f * (1.0f - t) + 1.0f;\n}",
    "c_group_1_id_517": "CGLM_INLINE\nfloat\nglm_ease_quart_inout(float t);\nCGLM_INLINE\nfloat\nglm_ease_quart_inout(float t) {\n  float f, g;\n\n  if (t < 0.5f) {\n    f = t * t;\n    return 8.0f * f * f;\n  }\n\n  f = t - 1.0f;\n  g = f * f;\n\n  return -8.0f * g * g + 1.0f;\n}",
    "c_group_1_id_518": "CGLM_INLINE\nfloat\nglm_ease_quint_in(float t);\nCGLM_INLINE\nfloat\nglm_ease_quint_in(float t) {\n  float f;\n  f = t * t;\n  return f * f * t;\n}",
    "c_group_1_id_519": "CGLM_INLINE\nfloat\nglm_ease_quint_out(float t);\nCGLM_INLINE\nfloat\nglm_ease_quint_out(float t) {\n  float f, g;\n\n  f = t - 1.0f;\n  g = f * f;\n\n  return g * g * f + 1.0f;\n}",
    "c_group_1_id_520": "CGLM_INLINE\nfloat\nglm_ease_back_in(float t);\nCGLM_INLINE\nfloat\nglm_ease_back_in(float t) {\n  float o, z;\n\n  o = 1.70158f;\n  z = ((o + 1.0f) * t) - o;\n\n  return t * t * z;\n}",
    "c_group_1_id_521": "CGLM_INLINE\nfloat\nglm_ease_back_out(float t);\nCGLM_INLINE\nfloat\nglm_ease_back_out(float t) {\n  float o, z, n;\n\n  o = 1.70158f;\n  n = t - 1.0f;\n  z = (o + 1.0f) * n + o;\n\n  return n * n * z + 1.0f;\n}",
    "c_group_1_id_522": "CGLM_INLINE\nfloat\nglm_ease_back_inout(float t);\nCGLM_INLINE\nfloat\nglm_ease_back_inout(float t) {\n  float o, z, n, m, s, x;\n\n  o = 1.70158f;\n  s = o * 1.525f;\n  x = 0.5f;\n  n = t / 0.5f;\n\n  if (n < 1.0f) {\n    z = (s + 1) * n - s;\n    m = n * n * z;\n    return x * m;\n  }\n\n  n -= 2.0f;\n  z  = (s + 1.0f) * n + s;\n  m  = (n * n * z) + 2;\n\n  return x * m;\n}",
    "c_group_1_id_523": "static WC_INLINE\n#if defined(WOLFSSL_FORCE_MALLOC_FAIL_TEST) || defined(WOLFSSL_ZEPHYR)\nTHREAD_RETURN\n#else\nWC_NORETURN void\n#endif\nerr_sys_with_errno(const char* msg);\nstatic WC_INLINE\n#if defined(WOLFSSL_FORCE_MALLOC_FAIL_TEST) || defined(WOLFSSL_ZEPHYR)\nTHREAD_RETURN\n#else\nWC_NORETURN void\n#endif\nerr_sys_with_errno(const char* msg)\n{\n#if !defined(__GNUC__)\n    /* scan-build (which pretends to be gnuc) can get confused and think the\n     * msg pointer can be null even when hardcoded and then it won't exit,\n     * making null pointer checks above the err_sys() call useless.\n     * We could just always exit() but some compilers will complain about no\n     * possible return, with gcc we know the attribute to handle that with\n     * WC_NORETURN. */\n    if (msg)\n#endif\n    {\n#if defined(HAVE_STRING_H) && defined(HAVE_ERRNO_H)\n        fprintf(stderr, \"wolfSSL error: %s: %s\\n\", msg, strerror(errno));\n#else\n        fprintf(stderr, \"wolfSSL error: %s\\n\", msg);\n#endif\n    }\n    XEXIT_T(EXIT_FAILURE);\n}",
    "c_group_1_id_524": "std::tm gmtime(const std::time_t &time_tt) SPDLOG_NOEXCEPT;\nstd::tm gmtime(const std::time_t &time_tt) SPDLOG_NOEXCEPT {\n#ifdef _WIN32\n    std::tm tm;\n    ::gmtime_s(&tm, &time_tt);\n#else\n    std::tm tm;\n    ::gmtime_r(&time_tt, &tm);\n#endif\n    return tm;\n}",
    "c_group_1_id_525": "size_t _thread_id() SPDLOG_NOEXCEPT;\nsize_t _thread_id() SPDLOG_NOEXCEPT {\n#ifdef _WIN32\n    return static_cast<size_t>(::GetCurrentThreadId());\n#elif defined(__linux__)\n    #if defined(__ANDROID__) && defined(__ANDROID_API__) && (__ANDROID_API__ < 21)\n        #define SYS_gettid __NR_gettid\n    #endif\n    return static_cast<size_t>(::syscall(SYS_gettid));\n#elif defined(_AIX)\n    struct __pthrdsinfo buf;\n    int reg_size = 0;\n    pthread_t pt = pthread_self();\n    int retval = pthread_getthrds_np(&pt, PTHRDSINFO_QUERY_TID, &buf, sizeof(buf), NULL, &reg_size);\n    int tid = (!retval) ? buf.__pi_tid : 0;\n    return static_cast<size_t>(tid);\n#elif defined(__DragonFly__) || defined(__FreeBSD__)\n    return static_cast<size_t>(::pthread_getthreadid_np());\n#elif defined(__NetBSD__)\n    return static_cast<size_t>(::_lwp_self());\n#elif defined(__OpenBSD__)\n    return static_cast<size_t>(::getthrid());\n#elif defined(__sun)\n    return static_cast<size_t>(::thr_self());\n#elif __APPLE__\n    uint64_t tid;\n    // There is no pthread_threadid_np prior to Mac OS X 10.6, and it is not supported on any PPC,\n    // including 10.6.8 Rosetta. __POWERPC__ is Apple-specific define encompassing ppc and ppc64.\n    #ifdef MAC_OS_X_VERSION_MAX_ALLOWED\n    {\n        #if (MAC_OS_X_VERSION_MAX_ALLOWED < 1060) || defined(__POWERPC__)\n        tid = pthread_mach_thread_np(pthread_self());\n        #elif MAC_OS_X_VERSION_MIN_REQUIRED < 1060\n        if (&pthread_threadid_np) {\n            pthread_threadid_np(nullptr, &tid);\n        } else {\n            tid = pthread_mach_thread_np(pthread_self());\n        }\n        #else\n        pthread_threadid_np(nullptr, &tid);\n        #endif\n    }\n    #else\n    pthread_threadid_np(nullptr, &tid);\n    #endif\n    return static_cast<size_t>(tid);\n#else  // Default to standard C++11 (other Unix)\n    return static_cast<size_t>(std::hash<std::thread::id>()(std::this_thread::get_id()));\n#endif\n}"
}